# 字母异位词

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

```
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        std::unordered_map<std::string, std::vector<std::string>> map;

        for (const auto& str : strs) {
            // 创建一个临时字符串用于排序
            std::string key = str;
            std::sort(key.begin(), key.end()); // 对字符串排序
            map[key].push_back(str); // 将原字符串加入到对应的键中
        }

        std::vector<std::vector<std::string>> result;
        for (const auto& pair : map) {
            result.push_back(pair.second); // 将每个分组加入结果
        }

        return result;
    }
};
```

# 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
class Solution{
public:
    int longestConsecutive(vector<int>& nums){
        if(nums.size() < 2) return nums.size();
        sort(nums.begin(), nums.end());
        int lenmax = 0;
        int len = 1;
        for(int i=1; i<nums.size(); i++){
            if(nums[i] == nums[i-1]+1) len++;
            else if(nums[i] == nums[i-1]) continue;
            else{
                lenmax = (lenmax > len) ? lenmax:len;
                len=1;
            }
        }
        return max(len, lenmax);
    }
};
```

# 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0;
        while (right < n) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};
```

另外

```
    void moveZeroes(vector<int>& nums) {
        int j=0;
        for(int i=0; i<nums.size(); i++){
            if(nums[i] != 0){
                nums[j] = nums[i];
                if(i != j){
                    nums[i] = 0;
                }
                j++;
            }
        }
    }
```

# [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

```
我自己写的
class Solution {
public:
    int maxArea(vector<int>& height) {
        int result = 0;
        int left = 0;
        int right = height.size()-1;
        int length = 0;

        while(left<right){
            if(height[left] >= height[right]){
                length = height[right];
            }
            else{
                length = height[left];
            }
            int temp = (right-left)*length;
            result = temp > result ? temp:result;

            if(height[left] >= height[right]){
                right--;
            }
            else{
                left++;
            }
        }
        return result;
    }
};
```

官方题解

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while (l < r) {
            int area = min(height[l], height[r]) * (r - l);
            ans = max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            }
            else {
                --r;
            }
        }
        return ans;
    }
};
```

