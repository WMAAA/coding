# 万能输入

无符号

```
    vector<vector<int>> arr;
    string input;
    while(getline(cin, input)){
        if(input.size() > 0){
            stringstream ss(input);
            int num;
            vector<int> a;
            while(ss >> num){
                a.push_back(num);
            }
            arr.push_back(a);
        }
    }
```

有符号

```
    vector<vector<int>> res;
    string input;
    char *tok;
    while(getline(cin, input)){
        if(input.size() > 0){
            vector<int> a;
            tok = strtok((char*)input.c_str(), " ,[]");
            while(tok != NULL){
                a.push_back(stoi(tok));
                tok = strtok(NULL, " ,[]"); // 继续分割上一次的字符
            }
            res.push_back(a);
        }
    }
```

# coding

> 只说思路，不进行编码

#  栈与队列

1. 基础

2. 用栈实现队列

3. 用队列实现栈

4. 有效的括号：分三种情况，左边多，类型不对称，右边多

   - 判断类型，st进相反方向的括号。

5. 删除字符串中的所有相邻重复项。

   - 就是栈，一样的`pop`，不一样就`push`，最后从栈中取出，翻转一下。

   > 栈的目的就是存放遍历过的元素，当遍历当前元素时，去栈里看一下我们是不是遍历过相同数值的相邻元素。

6. 逆波兰表达式求值：是一种后缀表达式，就是指运算符写在后面。

   - 其实就是遇到数字就push，遇到运算符就取出，计算完后再push进去。
   - 最后，取出栈中最后一个元素，返回。

7. 滑动窗口最大值：**就是实现一个单调队列**

   - pop：
   - push


# 二叉树

1. 基础
2. 递归遍历
3. 统一迭代法
4. 层序遍历
5. 翻转二叉树
6. 二叉树周末总结

# **贪心算法**

1. 理论基础：常识性推导加举反例。
2. 分发饼干：饼干小孩排序。一层遍历加判断，能吃饱，好，那就加一 。`从大到小遍历`饼干。
3. 摆动序列：将数字写成山坡，把上山下山遇到的，全扔掉，那么我们记录的就是山峰。
   - 单调中间有平坡，上下中间有平坡
   - `动态规划还没看`

****

# **动态规划**

1. 动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

   > 1. 确定dp数组（dp table）以及下标的含义
   > 2. 确定递推公式
   > 3. dp数组如何初始化
   > 4. 确定遍历顺序
   > 5. 举例推导dp数组

2. 斐波那契数：人都把上面5个条件都写出来了，你直接按着写就行了，这还不行？

3.  爬楼梯： 你站到倒数一阶，只有一种走法，你站在倒数第二阶，除了上面那种走法，你还有另外一个选择，那就是直接越过。

   - `扩展没看`



# **单调栈**

1. 每日温度：要观测到更高气温要等待的天数

   - 两层`for`循环多简单呀，自讨苦吃

   - 单调栈的本质是 `空间换时间`，直接在栈中放元素索引。

     > 三个判断条件
     >
     > - 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
     > - 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
     > - 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
     >
     > 前两个都是直接往里面塞，最后大于的时候才更新栈顶的索引对应的result处的值。**弹出的都知道距离下一个是多远了**

# 图论

1. 理论基础
   - 邻接表，从边的角度考虑。有多少边申请对应大小的链表。
   - 邻接矩阵，n个节点，n*n，矩阵的元素是权重。**缺点是稀疏图**
   - 图的遍历方式
     - 深度优先搜索dfs
     - 广度优先搜索bfs
