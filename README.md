# coding
> 只说思路，不进行编码

#  栈与队列

1. 基础
2. 用栈实现队列
3. 用队列实现栈
4. 有效的括号

# **贪心算法**

1. 理论基础：常识性推导加举反例。
2. 分发饼干：饼干小孩排序。一层遍历加判断，能吃饱，好，那就加一 。`从大到小遍历`饼干。
3. 摆动序列：将数字写成山坡，把上山下山遇到的，全扔掉，那么我们记录的就是山峰。
   - 单调中间有平坡，上下中间有平坡
   - `动态规划还没看`

****

# **动态规划**

1. 动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

   > 1. 确定dp数组（dp table）以及下标的含义
   > 2. 确定递推公式
   > 3. dp数组如何初始化
   > 4. 确定遍历顺序
   > 5. 举例推导dp数组

2. 斐波那契数：人都把上面5个条件都写出来了，你直接按着写就行了，这还不行？

3.  爬楼梯： 你站到倒数一阶，只有一种走法，你站在倒数第二阶，除了上面那种走法，你还有另外一个选择，那就是直接越过。

   - `扩展没看`



# **单调栈**

1. 每日温度：要观测到更高气温要等待的天数

   - 两层`for`循环多简单呀，自讨苦吃

   - 单调栈的本质是 `空间换时间`，直接在栈中放元素索引。

     > 三个判断条件
     >
     > - 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
     > - 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
     > - 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
     >
     > 前两个都是直接往里面塞，最后大于的时候才更新栈顶的索引对应的result处的值。**弹出的都知道距离下一个是多远了**
